import random
from .LevelGenerator import LevelGenerator
from ..level.LevelData import LevelData
from ..level.MapCoord import MapCoord
from ..level.ObjectStore import ObjectStore
from ..level.GraphPaperMap import GraphPaperMap, CellType,MapMask
from ..level.ObjectFactory import create_object_from_template
from ..level.MapRoom import MapRoom
from .AStarAlgorithm import DigPathThroughStone
from .Network import Network
from ..behavior.BasicBehaviors import *

#The process here is that a dungeon level is generated by subdividing a rectangle into smaller rectangles
#after the smaller rectangles are made, they are assigned a room template, which will determine what kind of monsters and items are in the room
#then the rooms are connected by a minimal spanning tree

class DungeonLevelGenerator(LevelGenerator):
    def __init__(self,**kwargs):
        super().__init__(**kwargs)

    def generate(self):
        print("Generating dungeon level")
        
        self.generate_map(self.level)
       
        return self.level
    
    def generate_map(self,level):
        map=level.map
        center_x=int(map.width/2)
        center_y=int(map.height/2)


        outside_room=MapRoom([1,1,map.width-2,map.height-2],"hallway")
        level.room_store.add_room(outside_room)
        map.set_room("hallway")

        #let's try the room subdivision algorithm
        my_rect=[3,3,map.width-6,map.height-6]
        my_rects=self.recursive_subdivide([my_rect])

        level.map.fill(None,CellType.STONE)

        rooms=[]
        for rect in my_rects:
            room=MapRoom(rect,parent=outside_room)
            room.create_exits(2)
            room.dig_self_on_map(level.map)
            room.build_walls(level.map)
            rooms.append(room)
            level.room_store.add_room(room)

        #build a minimal spanning tree
        network=Network.fully_connected_network(len(rooms))
        network.prune_until_spanning_tree()
        for edge in network.edges:
            room1=rooms[edge[0]]
            room2=rooms[edge[1]]
            start=MapCoord(room1.get_center())
            finish=MapCoord(room2.get_center())
            #print("connecting",start,finish )
            path=DigPathThroughStone(level.map).find_path(start,finish)
            #print("path is ",path)
            if path is not None:
                for coord in path:
                    level.map.cells[coord.x][coord.y].cell_type=CellType.INDOOR_FLOOR

        #put walls up where relevant
        level.map.make_walls_on_boundaries(CellType.STONE,CellType.INDOOR_FLOOR)

        must_have_rooms=self.must_have_rooms
        #each room needs to be assigned a template
        #then each template is applied to the room
        for room in level.room_store.rooms.values():
            if room.id=="hallway":
                continue
            if len(must_have_rooms)>0:
                room_info=must_have_rooms.pop()
                template_name=room_info["template"]
                template=self.area_templates.get_template(template_name)
                template.apply_template(level,room)
                level.room_store.add_room_alias(room.id,room_info["name"])
                print("creating must have room with name ",room_info["name"])
            else:
                print("no must have rooms left, choosing random template")
                template=self.select_area_template()
                template.apply_template(level,room)
            #self.apply_template_to_room(template,room,level)

        center_x=rooms[0].rect[0]+rooms[0].rect[2]//2
        center_y=rooms[0].rect[1]+rooms[0].rect[3]//2

        #add some monsters
        #centerx2=rooms[1].rect[0]+rooms[1].rect[2]//2
        #centery2=rooms[1].rect[1]+rooms[1].rect[3]//2
        #monster=create_object_from_template("imp")
        #monster.behavior=BTRandomWalk()
        #monster.behavior=BTChasePlayer()
        #level.add_object_to_cell(monster,MapCoord(centerx2,centery2))


        #add some furniture
#        for room in rooms:
#            for i in range(3):
#                x=random.randint(room.rect[0]+1,room.rect[0]+room.rect[2]-2)
#                y=random.randint(room.rect[1]+1,room.rect[1]+room.rect[3]-2)
#                obj=create_object_from_template("standing_torch")
#                level.add_object_to_cell(obj,MapCoord(x,y))

        #add portals 
        self.add_portals(level)
        #lighting
        map.set_ambient_light(0)
        map.recalculate_lighting()
        level.memory_mask=MapMask(map.width,map.height)

        level.player_respawn_point=MapCoord(center_x,center_y)
        level.tileset_name="dungeon"
    
# for creating rooms with the division method
    def recursive_subdivide(self,rectlist):
        ret=[]
        for rect in rectlist:
            sub_list=self.subdivide(rect)
            if sub_list is not None:
                ret.extend(self.recursive_subdivide(sub_list))
            else:
                ret.append(rect)
        return ret

    def subdivide(self,rect):
        #print("subdivide",rect)
        min_size=3 # the smallest dimension a room can be
        padding=3 # the minimum distance between rooms
        if rect[2]>rect[3]: 
            #split vertically
            if rect[2]<min_size*2+padding:
                return None
            split=random.randint(min_size,rect[2]-min_size-padding)
            rect1=[rect[0],rect[1],split,rect[3]]
            rect2=[rect[0]+split+padding,rect[1],rect[2]-split-padding,rect[3]]
            return [rect1,rect2]
        else:
            #split horizontally
            if rect[3]<min_size*2+padding:
                return None
            split=random.randint(min_size,rect[3]-min_size-padding)
            rect1=[rect[0],rect[1],rect[2],split]
            rect2=[rect[0],rect[1]+split+padding,rect[2],rect[3]-split-padding]
            return [rect1,rect2]
        
    